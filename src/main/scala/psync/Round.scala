package psync

import io.netty.buffer.ByteBuf
import io.netty.buffer.ByteBufAllocator
import psync.formula._

import scala.pickling._
import binary._

//TODO not so nice (exn for control flow) but it will do for the moment
class TerminateInstance extends Exception() { }


/** A Round is the logical unit of time and communication in PSync.
 *
 * The rounds are parameterized by a type `A` which is the payload of the
 * messages sent during the round. To specify a round, the user needs to
 * extend this class and implement the `send` and `update` methods.
 * 
 * The round class provide some helper methods such as `broadcast`,
 * `exitAtEndOfRound`, and `terminate`.
 */
abstract class Round[A] {

  def send(): Map[ProcessID,A]

  def update(mailbox: Map[ProcessID,A]): Unit

  private var _continue = true
  protected final def exitAtEndOfRound(): Unit = {
    _continue = false
  }
  def getContinue = {
    val c = _continue
    _continue = true
    c
  }
  
  //TODO throwing so many exception might be expensive for normal control flow...
  protected final def terminate(): Nothing = {
    throw new TerminateInstance
  }
  
  /* Broadcast is a shortcut to send the same message to every participant. */
  protected final def broadcast[A](msg: A): Map[ProcessID,A] = {
    group.replicas.foldLeft(Map.empty[ProcessID,A])( (acc, r) => acc + (r.id -> msg) )
  }
  
  //TODO a better way to hide/abstract the group
  private var group: psync.runtime.Group = null
  def setGroup(g: psync.runtime.Group) {
    group = g
  }

  //TODO can we inter that from the send code ?
  def expectedNbrMessages: Int = group.size

}


/** During the compilation a macro wrap the user facing [[Round]]
 *  to make implement the [[RtRound]] interface used by the runtime.
 */
abstract class RoundWrapper extends RtRound {

  type A
  val r: Round[A]
  
  final def expectedNbrMessages: Int = r.expectedNbrMessages
  final def setGroup(g: psync.runtime.Group) { r.setGroup(g) }
  
  //serialization is generated by macros
  protected def serialize(payload: A, out: ByteBuf): Unit
  protected def deserialize(in: ByteBuf): A

  private var packetSize = -1
  
  override def setOptions(options: runtime.RuntimeOptions) {
    packetSize = options.packetSize
  }
  
  final def packSend(alloc: ByteBufAllocator): Map[ProcessID, ByteBuf] = {
    val msgs = r.send()
    msgs.map{ case (dst, value) =>
      val buf = if (packetSize >= 8) alloc.buffer(packetSize) else alloc.buffer()
      serialize(value, buf)
      (dst, buf)
    }
  }

  final def unpackUpdate(msg: Map[ProcessID, ByteBuf]): Boolean = {
    def decode(pkt: (ProcessID, ByteBuf)): (ProcessID, A) = pkt match { case (pid, buf) =>
      val a = deserialize(buf)
      buf.release
      (pid, a)
    }
    val decoded = msg.map(decode)
    //TODO TerminateInstance should be caught here (and the method should return true)
    r.update(decoded)
    r.getContinue
  }


}

/** RtRound is the interface of rounds used by the runtime. */
abstract class RtRound {
  
  def expectedNbrMessages: Int
  def packSend(alloc: ByteBufAllocator): Map[ProcessID, ByteBuf]
  def unpackUpdate(msg: Map[ProcessID, ByteBuf]): Boolean

  def setOptions(options: runtime.RuntimeOptions): Unit
  def setGroup(g: psync.runtime.Group): Unit

  //////////////////////
  // for verification //
  //////////////////////

  import verification._

  //macros will take care of overriding those methods
  def auxSpec: Map[String, AuxiliaryMethod] = Map.empty
  def rawTR: RoundTransitionRelation = new RoundTransitionRelation(
    True(), Variable("s"), True(), Variable("u"), Nil, Nil, Nil )
  def sendStr: String = ""
  def updtStr: String = ""

}
